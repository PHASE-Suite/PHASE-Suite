# Technical Analysis of the PHASE Explorer Visualization App

---

## Executive Summary

This report provides a comprehensive technical analysis of the **PHASE Explorer**, an interactive web application built with **Streamlit** (`phase_explorer.py`). This application serves as the second major component of **PHASE Suite**, designed to consume, analyze, and visualize the demultiplexed data generated by the `phase_pipeline.sh` script. The app transforms raw `.bases` and `.muts` files into a user-friendly graphical interface, enabling deep data exploration, rigorous statistical analysis, and the generation of publication-quality plots. It leverages a suite of Python libraries, including Pandas for data manipulation, Plotly for dynamic visualizations, and SciPy for statistical testing. The app's architecture emphasizes flexibility, allowing it to handle complex experimental designs, including time-matched controls, through intelligent file parsing and conditional logic.

---

## 1. Introduction to the Role of Visualization in ecNGS

While the command-line pipeline is essential for processing raw sequencing data into quantifiable metrics, the resulting text files are not readily interpretable. The primary goal of **PHASE Explorer** is to bridge the gap between raw data and scientific insight. It addresses several key challenges in ecNGS data analysis:

* **Interpretation of Large Datasets:** Manually calculating mutation frequencies and creating plots for dozens of samples and conditions is tedious and error-prone.
* **Statistical Rigor:** Determining if observed differences in mutation frequencies are statistically significant requires appropriate tests based on the experimental design.
* **Normalization and Context:** Raw mutation counts are meaningless without proper normalization against the number of bases sequenced and the underlying genomic trinucleotide frequencies.
* **Publication-Ready Figures:** Generating high-quality, customizable plots is a critical final step for communicating results.

**PHASE Explorer** is designed to automate these tasks in a robust, reproducible, and interactive manner, empowering researchers to focus on biological interpretation rather than data wrangling.

---

## 2. Overall Application Functionality

**PHASE Explorer** is a stateful **Streamlit** application that guides the user through a logical workflow, from data input to result export. Its functionality can be broken down into four main stages:

* **Stage 1: User Input and Configuration:** The user provides paths to the necessary input files via a sidebar interface. This includes the reference genome, the `indexing` folder from the pipeline, and options for filtering the dataset. The user also configures analysis-wide parameters, such as the control condition for statistical tests and plot customization settings.
* **Stage 2: Data Loading and Processing:** Upon clicking "Generate," the application reads the specified `.bases` and `.muts` files. It parses each filename to extract experimental metadata (Identifier, Condition, Barcode). It then calculates mutation frequencies, aggregates data, and extracts trinucleotide contexts for every mutation, structuring everything into a master Pandas DataFrame.
* **Stage 3: Statistical Analysis and Plot Generation:** The application performs statistical tests based on the user's selected control condition. It can perform a standard One-Way ANOVA with a Dunnett's post-hoc test for simple designs or time-matched t-tests for more complex experimental setups. It then uses this information to generate a suite of interactive plots using Plotly.
* **Stage 4: Results Display and Export:** The generated plots and their underlying data tables are displayed in a tabbed interface for easy exploration. The app provides a one-click "Download All" feature that packages every plot and data table into a single, organized `.zip` archive.

---

## 3. Detailed Script Analysis

### 3.1. Core Data Structures and Constants

The script begins by defining several key constants that ensure consistency across all analyses:

* **`MUTATION_GROUPS`**: A dictionary that maps all 12 possible base changes to the 6 standard substitution groups (e.g., G>T and C>A are both mapped to "G:C>T:A").
* **`DESIRED_GROUP_ORDER`**: A list that enforces a consistent plotting order for the 6 mutation groups.
* **`SUBSTITUTION_CLASSES` and `SUBSTITUTION_COLORS`**: Defines the 6 canonical substitution classes (e.g., "C>A") and their standard COSMIC colors, which are essential for the 96-channel mutation signature plots.

### 3.2. Data Ingestion and Processing (`process_files`)

This function is the primary data loading engine of the app.

* **File Discovery and Parsing:** It iterates through the user-selected `.bases` files. For each one, it constructs the path to the corresponding `.muts` file and verifies its existence. It then uses a regular expression (`'^(?P<identifier>[^_]+)_(?P<condition>.+?)\.bc(?P<barcode>\d+)'`) to capture the experimental metadata directly from the filename. This is a crucial step that makes the entire "smart statistics" feature possible.
* **Data Extraction:** It reads the total base count from the `.bases` file and all mutation data from the `.muts` file. For each mutation, it calculates two key pieces of information:
    * **Mutation Group:** It uses the `MUTATION_GROUPS` dictionary to classify the mutation.
    * **Trinucleotide Context:** It uses the `pyfaidx` library to access the reference genome FASTA file and extract the bases immediately upstream and downstream of the mutation. The `canonical_96_context` helper function ensures that the context is correctly converted to its canonical form on the pyrimidine base (C or T).
* **DataFrame Construction:** The function aggregates all this information for all files and returns a single, tidy Pandas DataFrame, where each row represents a single replicate (a unique `.bases`/`.muts` file pair).

### 3.3. Statistical Analysis (`plot_dose_response_plotly`)

While this function's primary purpose is plotting, it contains the application's core statistical logic. The choice of statistical test is determined by the user's selection in the "Select Control" dropdown.

* **Smart Control Detection:** The function first checks if the user selected a simple control condition (e.g., "0uM") or the special "Identifier: Control (Time-Matched)" option.
* **Time-Matched t-tests:** If time-matching is selected, the app assumes a more complex experimental design. For each treatment condition (e.g., "DrugA" at "24h"), it finds the corresponding control data (i.e., identifier = "Control" and condition = "24h"). It then performs an independent t-test (`ttest_ind`) between these two specific groups. This provides a more precise statistical comparison for two-factor experiments.
* **ANOVA and Dunnett's Test:** If a simple control is selected, the app performs a more standard analysis. For each identifier, it first runs a One-Way ANOVA (`f_oneway`) to determine if there are any significant differences among any of the conditions. It then uses the `scikit_posthocs` library to perform a Dunnett's post-hoc test (`posthoc_dunnett`), which specifically compares each treatment condition back to the single designated control condition.
* **Significance Annotation:** The resulting p-values from either statistical path are used to generate significance stars (e.g., `*` for p < 0.05) which are then automatically overlaid on the final bar plots.

### 3.4. Plotting and Visualization

The application generates three main categories of plots using the Plotly library, which allows for fully interactive charts (hover-to-view, zoom, pan).

#### 3.4.1. Dose-Response and Summary Plots

This plot shows the overall mutation frequency for each condition. It can be displayed as either separate bar charts for each identifier or as an overlay plot with lines connecting the means for direct comparison. The error bars represent the Standard Error of the Mean (SEM).

#### 3.4.2. Mutation Group Plots

This plot breaks down the overall mutation frequency into the 6 standard substitution groups. It is displayed as a series of stacked bar charts (one for each condition), allowing for easy comparison of the relative contributions of each mutation type.

#### 3.4.3. 96-Channel Mutational Signature Plots

These plots provide the most granular view of the mutational landscape. The app can generate them in three different normalization modes:

* **Traditional:** Normalizes the frequency of each trinucleotide context by its baseline abundance in the reference genome. This shows enrichment or depletion.
* **New:** Normalizes the observed count of mutations in a context by the expected count based on trinucleotide abundance and total bases sequenced.
* **Subtracted:** The "New" normalization value for the control condition is subtracted from the value for the treatment condition. This powerful visualization highlights the specific mutational signature being introduced by the treatment itself, removing the background signature. This mode intelligently uses the same time-matched or simple control logic from the statistical analysis section to select the correct control data for subtraction.
